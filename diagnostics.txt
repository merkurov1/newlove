Diagnostics run at: 2025-10-14T11:03:05Z
cwd: /workspaces/newlove
git HEAD: 7bcec91352b284dc5dc5421cfcb15ab06c18103e
\n-- git fetch --all --quiet --
\n-- git diff --name-status 59c1849f560f8a6106a6743d3243b0c3cfd2fd19..HEAD --
A	.build_pid
A	.devcontainer/Dockerfile
A	.devcontainer/README.md
M	.devcontainer/devcontainer.json
A	.github/workflows/ci.yml
A	.vercelignore
A	DEPLOYMENT_CHECKLIST.md
A	actions_run_18458057319_logs.zip
A	actions_run_18458057321_logs.zip
M	app/[slug]/page.js
M	app/admin/actions.js
M	app/admin/articles/edit/[id]/page.js
M	app/admin/articles/page.tsx
M	app/admin/layout.tsx
M	app/admin/letters/edit/[id]/page.js
M	app/admin/letters/page.tsx
M	app/admin/media/page.tsx
M	app/admin/page.tsx
M	app/admin/projects/page.tsx
M	app/admin/users-old/page.tsx
M	app/admin/users/page.tsx
A	app/api/admin/letters/test-render/route.ts
M	app/api/admin/letters/test-send/route.ts
M	app/api/admin/users/[id]/route.ts
M	app/api/admin/users/route.ts
M	app/api/admin/validate-slug/route.ts
M	app/api/article-by-slug/route.js
M	app/api/articles/[id]/route.js
M	app/api/articles/route.js
D	app/api/auth/[...nextauth]/route.ts
M	app/api/cron/route.ts
M	app/api/letters/route.ts
M	app/api/media/delete/route.ts
M	app/api/media/route.ts
M	app/api/media/upload/route.ts
M	app/api/messages/[id]/route.ts
M	app/api/messages/route.ts
M	app/api/newsletter-confirm/route.ts
M	app/api/newsletter-unsubscribe/route.ts
M	app/api/postcards/order-success/route.ts
M	app/api/postcards/order/route.ts
M	app/api/postcards/route.ts
D	app/api/privy-auth/route.ts
M	app/api/projects/[id]/route.ts
M	app/api/projects/route.ts
M	app/api/subscribers/[id]/route.ts
M	app/api/subscribers/route.ts
M	app/api/subscription-status/route.ts
M	app/api/test-auth/route.ts
M	app/api/upload/editor-image-supabase/route.ts
M	app/api/upload/editor-image/route.ts
M	app/api/upload/route.ts
M	app/articles/page.js
D	app/auth/error/page.tsx
D	app/auth/signin/page.tsx
M	app/debug-auth/page.tsx
M	app/digest/[slug]/page.js
M	app/kit/page.tsx
M	app/lab/bluesky/page.tsx
M	app/lab/feed/page.tsx
M	app/lab/integrations/page.tsx
M	app/lab/medium/page.tsx
M	app/lab/page.tsx
M	app/lab/youtube/page.tsx
M	app/layout.js
A	app/layout.js.bak-1760431648
M	app/letters/[slug]/page.tsx
M	app/letters/order-success/page.tsx
M	app/letters/page.tsx
A	app/onboard/page.tsx
A	app/onboard/secret/page.tsx
M	app/page.js
D	app/privy/page.tsx
M	app/profile/page.js
M	app/projects/page.tsx
M	app/providers.tsx
M	app/rss.xml/route.js
M	app/sitemap.ts
M	app/tags/[slug]/page.js
M	app/talks/TalksClientPage.tsx
M	app/talks/page.tsx
M	app/users/page.js
M	app/you/[username]/page.js
A	apply_final_emergency.sh
M	components/ArticleScrollNav.tsx
M	components/AuctionSlider.tsx
M	components/AuthGuard.tsx
M	components/AuthProvider.tsx
M	components/BlueskyFeed.tsx
M	components/DebugEditButton.tsx
M	components/EditButton.tsx
M	components/FlowFeed.tsx
M	components/Footer.js
M	components/Header.js
M	components/HeroHearts.js
M	components/ImageUploader.js
M	components/LinkPreview.js
M	components/Login.tsx
M	components/LoginButton.tsx
M	components/LoungeInterface.tsx
A	components/ModernLoginModal.tsx
M	components/SEO/StructuredData.tsx
A	components/SafeImage.tsx
M	components/UserSidebar.js
M	components/WalletLoginButton.tsx
M	components/WelcomeBanner.tsx
M	components/YouTubeShorts.tsx
M	components/admin/ContentForm.tsx
M	components/admin/UserEditModal.tsx
M	components/letters/PostcardOrderForm.tsx
M	components/letters/PostcardShop.tsx
A	docs/CI_PRISMA_NOTES.md
A	docs/SECRET_ROTATION.md
A	docs/SUPABASE-VALIDATION.md
A	dumps/articles.csv
A	dumps/articles.sql
A	dumps/letters.csv
A	dumps/letters.sql
A	emergency_fix.patch
A	hooks/useSupabaseSession.ts
M	jsconfig.json
A	layout_guard.patch
A	layout_guard.unified.patch
A	lib/attachTagsToArticles.js
A	lib/attachTagsToArticles.js.bak-1760431648
M	lib/authOptions.ts
A	lib/getSupabaseForRequest.js
A	lib/metadataSanitize.ts
A	lib/metadataSanitize.ts.bak-1760431648
M	lib/middleware/auth.ts
M	lib/newsletter/sendNewsletterToSubscriber.js
M	lib/prisma.ts
A	lib/safeSerialize.ts
A	lib/serverAuth.ts
M	lib/supabase-server.js
A	lib/supabase-server.ts
A	lib/supabaseInterop.js
A	lib/tags.ts
M	lib/validation/security.ts
A	local-build.log
A	logs/build-monitor.log
A	logs/next-build-full.log
A	logs/next-build.log
A	logs_52581261293.zip
A	logs_52581261302.zip
A	logs_52583116765.zip
A	logs_52583118497.zip
A	middleware.ts
M	next.config.js
A	nohup.out
A	npm-ci-after-lock.log
A	npm-ci-production.log
A	npm-ci.log
A	npm-install-2.log
A	npm-install-3.log
A	npm-install-lock.log
A	npm-install.log
M	package-lock.json
M	package.json
D	prisma/migrations/20250928054505_init/migration.sql
D	prisma/migrations/20250928055912_add_user_role/migration.sql
D	prisma/migrations/20250930_block_content/migration.sql
D	prisma/migrations/20250930_block_content_articles/migration.sql
D	prisma/migrations/20250930_block_content_digests/migration.sql
D	prisma/migrations/20251002_recreate_articles/migration.sql
D	prisma/migrations/20251002_recreate_products/migration.sql
D	prisma/migrations/migration_lock.toml
D	prisma/schema.prisma
D	schema.txt
A	scripts/check-table-privs.js
A	scripts/check_db_privs.sql
A	scripts/check_projects_table.js
A	scripts/cleanup-test-data.js
A	scripts/create_api_alias_views.sql
A	scripts/create_project_view.sql
A	scripts/db-diagnostics.js
A	scripts/db-fix-service-role.js
A	scripts/dump-tables.js
A	scripts/emergency/README.md
A	scripts/emergency/app_layout.js.bak-1760431648
A	scripts/find-admin.js
A	scripts/find_bad_metadata.js
A	scripts/grant-table-privs.js
A	scripts/grant-user-article-privs.js
A	scripts/grant_authenticated_selects.sql
A	scripts/grant_public_selects.sql
A	scripts/grants_and_rls.sql
A	scripts/grants_for_public_read.sql
A	scripts/import-dumps.js
A	scripts/import-users-to-supabase.js
A	scripts/import-users-to-supabase.mjs
D	scripts/migration-toolkit.js
A	scripts/remove-committed-secrets.sh
A	scripts/roles_update.json
A	scripts/run-sql.js
A	scripts/run_sql.sh
A	scripts/supabase-audit.json
A	scripts/supabase-client.js
A	scripts/test-tags.js
A	scripts/update-roles.mjs
A	scripts/users_export.json
D	scripts/vercel-migrate.sh
A	scripts/verify_view.js
A	tests/README.md
A	tests/playwright.config.js
A	tests/playwright.config.ts
A	tests/siwe-onboard.spec.js
A	tests/siwe-onboard.spec.ts
A	tmp/check_privs_and_policies.js
A	tsc-output.txt
M	tsconfig.json
A	types/dompurify.d.ts
A	types/framer-motion.d.ts
A	types/messages.ts
A	types/minimatch/index.d.ts
M	types/next-auth.d.ts
D	types/privy.d.ts
A	vercel.json
\n-- git diff for key files --
diff --git a/app/[slug]/page.js b/app/[slug]/page.js
index ab9cd63..9558593 100644
--- a/app/[slug]/page.js
+++ b/app/[slug]/page.js
@@ -1,11 +1,19 @@
 // app/[slug]/page.js
-import prisma from '@/lib/prisma';
+// Avoid static import to handle different module export shapes (named vs default)
+// and to prevent build-time import errors when the helper is implemented in .js vs .ts.
+async function getUserAndSupabaseFromRequest(req) {
+  const { getUserAndSupabaseFromRequestInterop } = await import('@/lib/supabaseInterop');
+  return getUserAndSupabaseFromRequestInterop(req);
+}
+import { safeData } from '@/lib/safeSerialize';
+import { sanitizeMetadata } from '@/lib/metadataSanitize';
 import { notFound } from 'next/navigation';
 import Link from 'next/link';
 import dynamic from 'next/dynamic';
 
 import Image from 'next/image';
 import { getFirstImage, generateDescription } from '@/lib/contentUtils';
+import { attachTagsToArticles } from '@/lib/attachTagsToArticles';
 import BlockRenderer from '@/components/BlockRenderer';
 import SocialShare from '@/components/SocialShare';
 import EditButton from '@/components/EditButton';
@@ -25,28 +33,47 @@ async function getContent(slug) {
   try {
     console.log('üì∞ Searching for article with slug:', slug);
     // –°–Ω–∞—á–∞–ª–∞ –∏—â–µ–º —Å—Ç–∞—Ç—å—é
-    const article = await prisma.article.findUnique({
-      where: { slug: slug, published: true },
-      include: {
-        author: { select: { name: true, image: true } },
-        tags: true,
-      },
-    });
+    const globalReq = (globalThis && globalThis.request) || new Request('http://localhost');
+    const { supabase } = await getUserAndSupabaseFromRequest(globalReq);
+    let article = null;
+    if (supabase) {
+      const { data, error } = await supabase.from('articles').select('*, author:authorId(name,image)').eq('slug', slug).eq('published', true).maybeSingle();
+      if (error) {
+        console.error('Supabase fetch article error', error);
+      } else {
+        // attach tags via helper if nested relation not available
+        let withTags = null;
+        if (data) {
+          if (Array.isArray(data)) {
+            withTags = await attachTagsToArticles(supabase, data);
+            withTags = Array.isArray(withTags) ? withTags : [];
+            article = withTags[0] || null;
+          } else {
+            // single object case
+            const attached = await attachTagsToArticles(supabase, [data]);
+            article = (Array.isArray(attached) && attached[0]) ? attached[0] : { ...data };
+          }
+        }
+      }
+    }
     
     if (article) {
       console.log('‚úÖ Found article:', article.title);
-      return { type: 'article', content: article };
+      return { type: 'article', content: safeData(article) };
     }
     
     console.log('üìÅ Searching for project with slug:', slug);
     // –ï—Å–ª–∏ —Å—Ç–∞—Ç—å—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –∏—â–µ–º –ø—Ä–æ–µ–∫—Ç
-    const project = await prisma.project.findUnique({
-      where: { slug: slug, published: true }
-    });
+    let project = null;
+    if (!article && supabase) {
+      const { data: p, error: pErr } = await supabase.from('project').select('*').eq('slug', slug).eq('published', true).maybeSingle();
+      if (pErr) console.error('Supabase fetch project error', pErr);
+      project = p;
+    }
     
     if (project) {
       console.log('‚úÖ Found project:', project.title);
-      return { type: 'project', content: project };
+      return { type: 'project', content: safeData(project) };
     }
     
     console.log('‚ùå No content found for slug:', slug);
@@ -94,7 +121,7 @@ export async function generateMetadata({ params }) {
       };
     }
 
-    return {
+    const meta = {
       title: content.title,
       description: description,
       openGraph: {
@@ -116,6 +143,9 @@ export async function generateMetadata({ params }) {
         }
       })
     };
+
+    // Ensure metadata contains only serializable values (no React elements/functions)
+    return sanitizeMetadata(meta);
   } catch (error) {
     return { 
       title: '–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏',
diff --git a/app/digest/[slug]/page.js b/app/digest/[slug]/page.js
index 1e21594..3da52fe 100644
--- a/app/digest/[slug]/page.js
+++ b/app/digest/[slug]/page.js
@@ -1,5 +1,6 @@
 // app/digest/[slug]/page.js
 import { createClient } from '../../../lib/supabase-server';
+import { sanitizeMetadata } from '@/lib/metadataSanitize';
 import { notFound } from 'next/navigation';
 import Link from 'next/link';
 import BlockRenderer from '@/components/BlockRenderer';
@@ -28,9 +29,9 @@ async function getDigestBySlug(slug) {
 // –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≤–æ –≤–∫–ª–∞–¥–∫–µ –±—Ä–∞—É–∑–µ—Ä–∞)
 export async function generateMetadata({ params }) {
   const digest = await getDigestBySlug(params.slug);
-  return {
+  return sanitizeMetadata({
     title: digest?.title || '–î–∞–π–¥–∂–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω',
-  };
+  });
 }
 
 
diff --git a/app/tags/[slug]/page.js b/app/tags/[slug]/page.js
index ebe5323..0e3ac57 100644
--- a/app/tags/[slug]/page.js
+++ b/app/tags/[slug]/page.js
@@ -1,43 +1,47 @@
 // app/tags/[slug]/page.js
 
-import prisma from '@/lib/prisma';
+// (helper loaded dynamically inside getTagData)
 import { notFound } from 'next/navigation';
 import Link from 'next/link';
+import { sanitizeMetadata } from '@/lib/metadataSanitize';
+import Image from 'next/image';
 import SafeImage from '@/components/SafeImage';
 
 // --- 1. –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ó–ê–ì–†–£–ó–ö–ò –î–ê–ù–ù–´–• ---
 // –ù–∞—Ö–æ–¥–∏—Ç —Ç–µ–≥ –ø–æ –µ–≥–æ slug –∏ –ø–æ–¥–≥—Ä—É–∂–∞–µ—Ç –≤—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–∏–º —Å—Ç–∞—Ç—å–∏
 async function getTagData(slug) {
-  // –î–µ–ª–∞–µ–º –ø–æ–∏—Å–∫ –ø–æ slug —Ä–µ–≥–∏—Å—Ç—Ä–æ–Ω–µ–∑–∞–≤–∏—Å–∏–º—ã–º
-  const tag = await prisma.tag.findFirst({
-    where: { slug: { equals: slug, mode: 'insensitive' } },
-    include: {
-      articles: {
-        where: { published: true },
-        orderBy: { publishedAt: 'desc' },
-        include: {
-          author: { select: { name: true, image: true } },
-          tags: true,
-        },
-      },
-      // –í –±—É–¥—É—â–µ–º –º–æ–∂–Ω–æ –±—É–¥–µ—Ç –¥–æ–±–∞–≤–∏—Ç—å –∏ –ø—Ä–æ–µ–∫—Ç—ã
-      // projects: { ... }
-    },
+  const globalReq = (globalThis && globalThis.request) || new Request('http://localhost');
+  const { getSupabaseForRequest } = await import('@/lib/getSupabaseForRequest');
+  const { supabase } = await getSupabaseForRequest(globalReq) || {};
+  if (!supabase) notFound();
+  // –ü–æ–∏—Å–∫ —Ç–µ–≥–∞ –ø–æ slug (—Ä–µ–≥–∏—Å—Ç—Ä –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –≤—Ä—É—á–Ω—É—é)
+  const { data: tags } = await supabase.from('Tag').select('*').ilike('slug', slug).limit(1);
+  const tag = (tags && tags[0]) || null;
+  if (!tag) notFound();
+  // –ü–æ–ª—É—á–∞–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å—Ç–∞—Ç—å–∏ —á–µ—Ä–µ–∑ junction _ArticleToTag
+  const { data: articles } = await supabase.rpc('get_articles_by_tag', { tag_slug: tag.slug }).catch(async () => {
+    // fallback: query articles by checking tags relation manually if rpc not present
+    const { data: rels } = await supabase.from('_ArticleToTag').select('A').eq('B', tag.id);
+    const ids = (rels || []).map(r => r.A);
+    if (ids.length === 0) return { data: [] };
+    const { data: arts } = await supabase.from('articles').select('*, author:authorId(name,image)').in('id', ids).eq('published', true).order('publishedAt', { ascending: false });
+    // attach tags via helper
+    const { attachTagsToArticles } = await import('@/lib/attachTagsToArticles');
+  const artsWithTags = await attachTagsToArticles(supabase, arts || []);
+  return { data: (artsWithTags && Array.isArray(artsWithTags)) ? artsWithTags : [] };
   });
-
-  if (!tag) {
-    notFound();
-  }
+  tag.articles = (articles && (articles.data || articles)) || [];
   return tag;
 }
 
 // --- 2. –ì–ï–ù–ï–†–ò–†–£–ï–ú –ú–ï–¢–ê–î–ê–ù–ù–´–ï –î–õ–Ø SEO ---
 export async function generateMetadata({ params }) {
   const tag = await getTagData(params.slug);
-  return {
+  const meta = {
     title: `–ú–∞—Ç–µ—Ä–∏–∞–ª—ã –ø–æ —Ç–µ–≥—É: ${tag.name}`,
     description: `–í—Å–µ —Å—Ç–∞—Ç—å–∏ –∏ –ø—Ä–æ–µ–∫—Ç—ã, –æ—Ç–º–µ—á–µ–Ω–Ω—ã–µ —Ç–µ–≥–æ–º "${tag.name}"`,
   };
+  return sanitizeMetadata(meta);
 }
 
 // --- 3. –°–ê–ú –ö–û–ú–ü–û–ù–ï–ù–¢ –°–¢–†–ê–ù–ò–¶–´ ---
diff --git a/app/you/[username]/page.js b/app/you/[username]/page.js
index 7c705af..e6047e3 100644
--- a/app/you/[username]/page.js
+++ b/app/you/[username]/page.js
@@ -1,9 +1,10 @@
 // app/you/[username]/page.js
 
 
-import prisma from '@/lib/prisma';
+// Supabase helper is loaded dynamically inside getUserProfile to avoid build-time issues
 import { notFound } from 'next/navigation';
 import Link from 'next/link';
+import { sanitizeMetadata } from '@/lib/metadataSanitize';
 import Image from 'next/image';
 import { Suspense } from 'react';
 import { getFirstImage } from '@/lib/contentUtils';
@@ -21,35 +22,36 @@ function FallbackAvatar({ name }) {
 // --- 1. –§–£–ù–ö–¶–ò–Ø –î–õ–Ø –ó–ê–ì–†–£–ó–ö–ò –î–ê–ù–ù–´–• –ü–†–û–§–ò–õ–Ø ---
 // –ù–∞—Ö–æ–¥–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username –∏ –ø–æ–¥–≥—Ä—É–∂–∞–µ—Ç –µ–≥–æ –∫–æ–Ω—Ç–µ–Ω—Ç
 async function getUserProfile(username) {
-  const user = await prisma.user.findUnique({
-    where: { username },
-    include: {
-      articles: {
-        where: { published: true },
-        orderBy: { publishedAt: 'desc' },
-        include: { tags: true },
-      },
-      projects: {
-        where: { published: true },
-        orderBy: { publishedAt: 'desc' },
-        include: { tags: true },
-      }
-    },
-  });
-
-  if (!user) {
-    notFound();
-  }
-  return user;
+  const globalReq = (globalThis && globalThis.request) || new Request('http://localhost');
+  const { getSupabaseForRequest } = await import('@/lib/getSupabaseForRequest');
+  const { supabase } = await getSupabaseForRequest(globalReq) || {};
+  if (!supabase) notFound();
+  const { data: users } = await supabase.from('users').select('*').eq('username', username).limit(1);
+  const user = (users && users[0]) || null;
+  if (!user) notFound();
+  // Fetch articles and projects separately
+  const { data: articlesRaw } = await supabase.from('articles').select('*').eq('authorId', user.id).eq('published', true).order('publishedAt', { ascending: false });
+  const { data: projectsRaw } = await supabase.from('project').select('*').eq('authorId', user.id).eq('published', true).order('publishedAt', { ascending: false });
+  // attach tags to articles and projects where needed
+  const { attachTagsToArticles } = await import('@/lib/attachTagsToArticles');
+  const articles = await attachTagsToArticles(supabase, articlesRaw || []);
+  const projects = await attachTagsToArticles(supabase, projectsRaw || []);
+  // Do not mutate original DB object; return a safe clone with serialized arrays
+  return {
+    ...user,
+    articles: Array.isArray(articles) ? JSON.parse(JSON.stringify(articles)) : [],
+    projects: Array.isArray(projects) ? JSON.parse(JSON.stringify(projects)) : []
+  };
 }
 
 // --- 2. –ì–ï–ù–ï–†–ò–†–£–ï–ú –ú–ï–¢–ê–î–ê–ù–ù–´–ï –î–õ–Ø SEO ---
 export async function generateMetadata({ params }) {
   const user = await getUserProfile(params.username);
-  return {
+  const meta = {
     title: `–ü—Ä–æ—Ñ–∏–ª—å: ${user.name}`,
     description: user.bio || `–ü—É–±–ª–∏—á–Ω—ã–µ —Å—Ç–∞—Ç—å–∏ –∏ –ø—Ä–æ–µ–∫—Ç—ã –∞–≤—Ç–æ—Ä–∞ ${user.name}`,
   };
+  return sanitizeMetadata(meta);
 }
 
 // --- 3. –°–ê–ú –ö–û–ú–ü–û–ù–ï–ù–¢ –°–¢–†–ê–ù–ò–¶–´ ---
diff --git a/lib/attachTagsToArticles.js b/lib/attachTagsToArticles.js
new file mode 100644
index 0000000..99b85d9
--- /dev/null
+++ b/lib/attachTagsToArticles.js
@@ -0,0 +1,85 @@
+// lib/attachTagsToArticles.js
+// Refactored implementation:
+// - No service-role fallback attempts (do not try srvSupabase on 42501)
+// - Assume RLS is configured to allow SELECT on ArticleToTag and tags
+// - Always return JSON-serializable results (JSON round-trip)
+// - On DB error (except permission-related attempts), log and return empty tags
+// - Does not mutate input objects
+export async function attachTagsToArticles(supabase, articles) {
+  // Defensive: ensure articles is an array
+  if (!Array.isArray(articles) || articles.length === 0) return [];
+
+  try {
+    // Extract article IDs in a safe numeric/string form
+    const articleIds = articles.map((a) => a && (a.id ?? a._id ?? a.articleId)).filter(Boolean);
+
+    if (articleIds.length === 0) {
+      // Nothing to attach
+      return JSON.parse(JSON.stringify(articles.map((a) => ({ ...a, tags: [] }))));
+    }
+
+    // Query junction table and tags using canonical column names.
+    // The schema uses columns "A" (article id) and "B" (tag id) in _ArticleToTag
+    const { data: relations, error: relErr } = await supabase
+      .from('_ArticleToTag')
+      .select('A,B')
+      .in('A', articleIds);
+
+    if (relErr) {
+      // Log and return articles with empty tags ‚Äî do not attempt a service-role retry
+      console.error('attachTagsToArticles: failed to fetch _ArticleToTag relations', relErr);
+      return JSON.parse(JSON.stringify(articles.map((a) => ({ ...a, tags: [] }))));
+    }
+
+  const tagIds = Array.from(new Set((relations || []).map((r) => r.B).filter(Boolean)));
+
+    let tagsById = {};
+    if (tagIds.length > 0) {
+      // Tags table in this schema is named `Tag`
+      const { data: tags, error: tagsErr } = await supabase
+        .from('Tag')
+        .select('id,name,slug')
+        .in('id', tagIds);
+
+      if (tagsErr) {
+        console.error('attachTagsToArticles: failed to fetch tags', tagsErr);
+        // In case of tags fetch error, still return articles with empty tags
+        return JSON.parse(JSON.stringify(articles.map((a) => ({ ...a, tags: [] }))));
+      }
+
+      tagsById = (tags || []).reduce((acc, t) => {
+        acc[t.id] = t;
+        return acc;
+      }, {});
+    }
+
+    // Build tags list per article
+    const tagsMap = (relations || []).reduce((acc, rel) => {
+      const aid = rel.A;
+      const tid = rel.B;
+      if (!acc[aid]) acc[aid] = [];
+      const tag = tagsById[tid];
+      if (tag) acc[aid].push(tag);
+      return acc;
+    }, {});
+
+    // Attach tags, do not mutate original objects
+    const result = articles.map((a) => {
+      const aid = a && (a.id ?? a._id ?? a.articleId);
+      const attached = tagsMap[aid] || [];
+      return { ...a, tags: attached };
+    });
+
+    // Ensure serialization compatibility for RSC
+    return JSON.parse(JSON.stringify(result));
+  } catch (error) {
+    // Catch-all: log and return empty tags to avoid crashing Server Components
+    console.error('attachTagsToArticles: unexpected error', error);
+    try {
+      return JSON.parse(JSON.stringify(articles.map((a) => ({ ...a, tags: [] }))));
+    } catch (e) {
+      // Worst-case fallback
+      return [];
+    }
+  }
+}
diff --git a/lib/getSupabaseForRequest.js b/lib/getSupabaseForRequest.js
new file mode 100644
index 0000000..a7cf20e
--- /dev/null
+++ b/lib/getSupabaseForRequest.js
@@ -0,0 +1,19 @@
+// lib/getSupabaseForRequest.js
+export async function getSupabaseForRequest(req) {
+  try {
+    const mod = await import('@/lib/supabase-server');
+    const fn = mod.getUserAndSupabaseFromRequest || mod.default || mod;
+    const res = await fn(req);
+    if (res && res.supabase) return { supabase: res.supabase, isServer: false, user: res.user };
+  } catch (e) {
+    // ignore and fall through to service role
+  }
+
+  try {
+    const srv = await import('@/lib/serverAuth');
+    const supabase = srv.getServerSupabaseClient();
+    return { supabase, isServer: true };
+  } catch (e) {
+    return { supabase: null, isServer: false };
+  }
+}
diff --git a/lib/metadataSanitize.ts b/lib/metadataSanitize.ts
new file mode 100644
index 0000000..c399e2d
--- /dev/null
+++ b/lib/metadataSanitize.ts
@@ -0,0 +1,227 @@
+// lib/metadataSanitize.ts
+// Ensure metadata values are serializable for Next.js (no React elements, functions, symbols).
+export function sanitizeMetadata(input: any): any {
+  const DIAG = process.env.METADATA_DIAG === 'true';
+  const seen = new WeakSet();
+
+  function isReactElement(obj: any) {
+    if (!obj || typeof obj !== 'object') return false;
+    return Object.prototype.hasOwnProperty.call(obj, '$$typeof');
+  }
+
+  function constructorName(v: any) {
+    try {
+      return v && v.constructor && v.constructor.name ? v.constructor.name : typeof v;
+    } catch (e) {
+      return typeof v;
+    }
+  }
+
+  function previewValue(v: any) {
+    try {
+      if (typeof v === 'string') return v.slice(0, 200);
+      if (typeof v === 'number' || typeof v === 'boolean') return String(v);
+      if (v === null || v === undefined) return String(v);
+      if (Array.isArray(v)) return `[Array(${v.length})]`;
+      if (v instanceof Date) return `Date(${v.toISOString()})`;
+      if (v instanceof URL) return `URL(${v.toString()})`;
+      if (v instanceof RegExp) return `RegExp(${v.toString()})`;
+      if (typeof v === 'object') return Object.keys(v).slice(0, 10).join(', ');
+      return typeof v;
+    } catch (e) {
+      return typeof v;
+    }
+  }
+
+  function logDiag(path: string[], value: any, reason: string) {
+    if (!DIAG) return;
+    try {
+      const p = path.length ? path.join('.') : '<root>';
+      const preview = previewValue(value);
+      const cname = constructorName(value);
+      const stack = new Error().stack;
+      // eslint-disable-next-line no-console
+      console.error(`SANITIZE DIAG: ${reason} at metadata.${p} constructor=${cname} preview=${preview}`);
+      // eslint-disable-next-line no-console
+      console.error(stack);
+    } catch (e) {
+      // swallow
+    }
+  }
+
+  function isPromiseLike(v: any) {
+    return v && (typeof v.then === 'function' || Object.prototype.toString.call(v) === '[object Promise]');
+  }
+
+  function isRequestLike(v: any) {
+    const name = constructorName(v);
+    return name === 'Request' || name === 'NextRequest' || (v && typeof v.headers === 'object' && typeof v.method === 'string');
+  }
+
+  function isResponseLike(v: any) {
+    const name = constructorName(v);
+    return name === 'Response' || name === 'NextResponse' || (v && typeof v.json === 'function' && typeof v.headers === 'object');
+  }
+
+  function isStreamLike(v: any) {
+    const name = constructorName(v);
+    return name === 'ReadableStream' || name === 'Stream' || (v && typeof v.getReader === 'function');
+  }
+
+  function isMapLike(v: any) {
+    return v instanceof Map || Object.prototype.toString.call(v) === '[object Map]';
+  }
+
+  function isSetLike(v: any) {
+    return v instanceof Set || Object.prototype.toString.call(v) === '[object Set]';
+  }
+
+  function isArrayBufferLike(v: any) {
+    return v instanceof ArrayBuffer || ArrayBuffer.isView(v) || Object.prototype.toString.call(v).includes('ArrayBuffer') || Object.prototype.toString.call(v).includes('Uint8');
+  }
+
+  function isURLSearchParams(v: any) {
+    return Object.prototype.toString.call(v) === '[object URLSearchParams]';
+  }
+
+  function sanitize(value: any, path: string[] = []): any {
+    if (value == null) return value;
+    const t = typeof value;
+
+    // Primitives
+    if (t === 'string' || t === 'number' || t === 'boolean') return value;
+    if (t === 'bigint' || t === 'symbol' || t === 'function') {
+      logDiag(path, value, `unsupported-type:${t}`);
+      return undefined;
+    }
+
+    // Promise-like -> drop
+    if (isPromiseLike(value)) {
+      logDiag(path, value, 'promise-like');
+      return undefined;
+    }
+
+    // Dates -> ISO
+    if (value instanceof Date) return isNaN(value.getTime()) ? undefined : value.toISOString();
+    // URLs/RegExp -> toString
+    if (value instanceof URL) return value.toString();
+    if (value instanceof RegExp) return value.toString();
+
+    // Request/Response/Stream/Headers detection
+    if (isRequestLike(value)) {
+      logDiag(path, value, 'request-like');
+      return undefined;
+    }
+    if (isResponseLike(value)) {
+      logDiag(path, value, 'response-like');
+      return undefined;
+    }
+    if (isStreamLike(value)) {
+      logDiag(path, value, 'stream-like');
+      return undefined;
+    }
+
+    // Arrays: sanitize items and drop undefined
+    if (Array.isArray(value)) {
+      const arr = value.map((it, i) => sanitize(it, path.concat(String(i)))).filter(v => v !== undefined);
+      return arr;
+    }
+
+    // Map -> convert to plain object with sanitized keys
+    if (isMapLike(value)) {
+      logDiag(path, value, 'map-like');
+      const out: any = {};
+      try {
+        for (const [k, v] of value.entries()) {
+          const key = typeof k === 'string' ? k : String(k);
+          const sv = sanitize(v, path.concat(String(key)));
+          if (sv !== undefined) out[key] = sv;
+        }
+        return out;
+      } catch (e) {
+        logDiag(path, value, 'map-convert-failed');
+        return undefined;
+      }
+    }
+
+    // Set -> convert to array
+    if (isSetLike(value)) {
+      logDiag(path, value, 'set-like');
+      try {
+        const arr = Array.from(value).map((it, i) => sanitize(it, path.concat(String(i)))).filter(v => v !== undefined);
+        return arr;
+      } catch (e) {
+        logDiag(path, value, 'set-convert-failed');
+        return undefined;
+      }
+    }
+
+    // ArrayBuffer / TypedArray -> convert to array of numbers
+    if (isArrayBufferLike(value)) {
+      logDiag(path, value, 'arraybuffer-like');
+      try {
+        const view = ArrayBuffer.isView(value) ? value : new Uint8Array(value);
+        return Array.from(view as any).slice(0, 10240); // cap length
+      } catch (e) {
+        logDiag(path, value, 'arraybuffer-convert-failed');
+        return undefined;
+      }
+    }
+
+    if (isURLSearchParams(value)) {
+      try {
+        return value.toString();
+      } catch (e) {
+        logDiag(path, value, 'urlsearchparams');
+        return undefined;
+      }
+    }
+
+    // Objects: drop React elements and circular refs
+    if (t === 'object') {
+      if (isReactElement(value)) {
+        logDiag(path, value, 'react-element');
+        return undefined;
+      }
+      if (seen.has(value)) {
+        logDiag(path, value, 'circular');
+        return undefined;
+      }
+      seen.add(value);
+
+      // If this is a class instance with custom toJSON, prefer that
+      if (typeof value.toJSON === 'function' && value.constructor && value.constructor.name !== 'Object') {
+        try {
+          const j = value.toJSON();
+          return sanitize(j, path.concat('<toJSON>'));
+        } catch (e) {
+          logDiag(path, value, 'toJSON-failed');
+        }
+      }
+
+      const out: any = {};
+      // iterate own enumerable keys only
+      for (const k of Object.keys(value)) {
+        try {
+          const v = sanitize(value[k], path.concat(k));
+          if (v !== undefined) out[k] = v;
+        } catch (err) {
+          // skip problematic property but log diag
+          logDiag(path.concat(k), value[k], 'property-skip');
+        }
+      }
+
+      // If resulting object is empty but original had non-plain constructor, log it
+      if (Object.keys(out).length === 0 && value.constructor && value.constructor.name && value.constructor.name !== 'Object') {
+        logDiag(path, value, `class-instance:${value.constructor.name}`);
+      }
+      return out;
+    }
+
+    // Fallback: unsupported
+    logDiag(path, value, `fallback-unsupported:${t}`);
+    return undefined;
+  }
+
+  return sanitize(input, []);
+}
diff --git a/lib/serverAuth.ts b/lib/serverAuth.ts
new file mode 100644
index 0000000..aad7582
--- /dev/null
+++ b/lib/serverAuth.ts
@@ -0,0 +1,102 @@
+import { createClient, SupabaseClient } from '@supabase/supabase-js';
+
+type ServerAuthOptions = {
+  useServiceRole?: boolean; // explicit opt-in to service role key
+};
+
+/**
+ * Create a Supabase client intended for server-only use.
+ * By default this prefers NON-service keys (SUPABASE_KEY) unless explicitly
+ * requested via options.useServiceRole. This avoids accidentally using
+ * the service_role key in runtime paths that shouldn't have elevated privileges.
+ */
+export function getServerSupabaseClient(options: ServerAuthOptions = {}): SupabaseClient {
+  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || process.env.SUPABASE_URL;
+  const preferServiceRole = !!options.useServiceRole;
+
+  const supabaseKey = preferServiceRole
+    ? process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_KEY
+    : process.env.SUPABASE_KEY || process.env.SUPABASE_SERVICE_ROLE_KEY;
+
+  if (!supabaseUrl || !supabaseKey) {
+    throw new Error('Supabase env vars missing: NEXT_PUBLIC_SUPABASE_URL|SUPABASE_URL and SUPABASE_KEY (or SUPABASE_SERVICE_ROLE_KEY) are required');
+  }
+
+  return createClient(supabaseUrl, supabaseKey, { auth: { persistSession: false } });
+}
+
+/**
+ * Try to retrieve the server user using the server Supabase client.
+ * Returns null on any failure to avoid throwing from common server-side flows.
+ */
+export async function getServerUser(): Promise<any | null> {
+  try {
+    const supabase = getServerSupabaseClient();
+    const { data, error } = await supabase.auth.getUser();
+    if (error) {
+      console.error('getServerUser supabase.auth.getUser error', error);
+      return null;
+    }
+    return (data as any)?.user || null;
+  } catch (e) {
+    console.error('getServerUser failed', e);
+    return null;
+  }
+}
+
+export async function requireUser(): Promise<any> {
+  const user = await getServerUser();
+  if (!user) throw new Error('Unauthorized');
+  return user;
+}
+
+export async function requireAdmin(): Promise<any> {
+  const user = await getServerUser();
+  if (!user) throw new Error('Unauthorized');
+  const role = ((user as any).user_metadata as any)?.role || (user as any)?.role || 'USER';
+  if (role !== 'ADMIN') throw new Error('Unauthorized');
+  return user;
+}
+
+/**
+ * Require admin, preferring request-based session validation if a Request
+ * object is provided. Falls back to ADMIN_API_SECRET and finally to the
+ * server-key-based check.
+ */
+export async function requireAdminFromRequest(req?: Request | null): Promise<any> {
+  if (req) {
+    try {
+      const { getUserAndSupabaseFromRequestInterop } = await import('./supabaseInterop');
+      const maybe = await getUserAndSupabaseFromRequestInterop(req as Request);
+      const user = maybe?.user || null;
+      if (user?.id) {
+        const role = (user.user_metadata && user.user_metadata.role) || user.role || 'USER';
+        if (role === 'ADMIN') return user;
+        throw new Error('Not authorized');
+      }
+    } catch (e) {
+      // Treat helper failures as unauthenticated and continue to other checks
+      console.error('requireAdminFromRequest: getUserAndSupabaseFromRequestInterop failed', e);
+    }
+  }
+
+  // Admin API secret fallback (keeps CI/dev workflows compatible)
+  if (process.env.ADMIN_API_SECRET) {
+    return { id: 'server', role: 'ADMIN' } as any;
+  }
+
+  // Final fallback: use server-key-based check which throws if unauthorized
+  return await requireAdmin();
+}
+
+// Provide a default export object to be resilient to different import styles
+const serverAuthDefault = {
+  getServerSupabaseClient,
+  getServerUser,
+  requireUser,
+  requireAdmin,
+  requireAdminFromRequest,
+};
+
+export default serverAuthDefault;
+
diff --git a/lib/supabase-server.js b/lib/supabase-server.js
index 0221661..5d68a7d 100644
--- a/lib/supabase-server.js
+++ b/lib/supabase-server.js
@@ -33,3 +33,45 @@ export function createClient() {
     }
   );
 }
+
+// Lightweight helper to get the current user from an App Router Request.
+// Accepts the standard Request and reads cookies to validate the session
+// using a centralized server-side Supabase client.
+export async function getUserAndSupabaseFromRequest(req) {
+  const cookieHeader = (req && req.headers && req.headers.get && req.headers.get('cookie')) || '';
+  const cookiesObj = Object.fromEntries(
+    cookieHeader
+      .split(';')
+      .map((s) => {
+        const [k, ...v] = s.split('=');
+        return [k && k.trim(), decodeURIComponent((v || []).join('='))];
+      })
+      .filter(Boolean)
+  );
+
+  const accessToken = cookiesObj['sb-access-token'] || cookiesObj['supabase-access-token'] || '';
+  if (!accessToken) return { user: null, supabase: null };
+
+  let supabase = null;
+  try {
+    supabase = createClient();
+  } catch (e) {
+    console.error('Unable to create server supabase client', e);
+    return { user: null, supabase: null };
+  }
+
+  try {
+    const { data: { user }, error } = await supabase.auth.getUser(accessToken);
+    if (error) {
+      console.error('Supabase getUser error', error);
+      return { user: null, supabase };
+    }
+    return { user, supabase };
+  } catch (e) {
+    console.error('Error validating supabase token', e);
+    return { user: null, supabase };
+  }
+}
+
+// Provide a default export as well for interop
+export default getUserAndSupabaseFromRequest;
\n-- git show 59c1849f560f8a6106a6743d3243b0c3cfd2fd19 --name-only --
commit 59c1849f560f8a6106a6743d3243b0c3cfd2fd19
Author: merkurov1 <97518066+merkurov1@users.noreply.github.com>
Date:   Sun Oct 12 07:30:21 2025 +0000

    SEO/AI best practices: JSON-LD, alt, aria-label, semantic HTML

app/[slug]/page.js
components/BlueskyFeed.tsx
components/FlowFeed.tsx
components/LinkPreview.js
components/LoungeInterface.tsx
components/MediumFeed.tsx
components/YouTubeShorts.tsx
components/letters/OrderSuccessContent.tsx
public/robots.txt
public/sitemap.xml
\n-- git log --oneline -n 50 --
7bcec91 fix(tags): use _ArticleToTag A/B columns and Tag table; safe serialization
cdba534 refactor(serverAuth): safer server Supabase client, explicit serviceRole opt-in, default export
9185ad8 fix(supabase): refactor attachTagsToArticles (RLS-safe, no service-role retries), sanitize server components outputs, and harden serverAuth interop
4a02794 fix(supabase): use interop helper; defensive article tag attach; homepage fixes; archive emergency artifacts
26fcb63 chore(emergency): final emergency sanitizer + attachTagsToArticles stub + layout guards (backups created)
d3d21a0 fix: strengthen metadata sanitizer + emergency attachTagsToArticles stub
64f69c4 chore: emergency stub attachTagsToArticles to avoid non-serializable values in metadata
b2fe973 fix: metadata sanitizer diagnostics + vercel/deploy scripts + ts/jsconfig tweaks; add .vercelignore
e55c9f9 chore(diagnostics): metadataSanitize optional diagnostic logging via METADATA_DIAG
4c3bee1 fix(digest): sanitize metadata in generateMetadata
5166476 fix: stricter metadataSanitize to drop React elements and non-serializable values
2c172f6 chore: temporarily skip _ArticleToTag access ‚Äî return empty tags to avoid permission errors
bd98b22 chore: commit all changes
d8a7402 attachTagsToArticles: retry junction/tags with service_role on permission denied (42501)
a42ce68 feat(supabase): fallback to server service_role for public reads via getSupabaseForRequest
41565f8 fix(db): replace nested tag selects with helper; add attachTagsToArticles helper; add SQL grants/rls templates
f370402 chore(db): add SQL scripts for grants and diagnostics + runner
b249ca4 fix(supabase): fallback to server service_role client for public reads (articles, homepage, lists)
bfcffaf sanit(metadata): wrap page metadata with sanitizeMetadata to avoid non-serializable values
929db48 fix(cron): use server Supabase client fallback when no user session available (cron)
4d86543 fix(metadata): sanitize tag and user generateMetadata outputs
cf44be8 fix(metadata): sanitize generateMetadata output to ensure only serializable values (prevent Unsupported Server Component type)
3d24c10 fix(supabase): resilient dynamic import lookup for getUserAndSupabaseFromRequest across server pages to avoid export interop runtime errors
21dd14c fix(supabase): ensure getUserAndSupabaseFromRequest is exported (JS interop)
5822176 fix(postcards): use 'postcards' table and postcard_orders relation
1de1a1c fix(supabase): resilient imports for getUserAndSupabaseFromRequest
05bed70 fix(db): use correct relation/table names for postcards and article authors
2621ec0 fix(postcards): use postcard_orders table for relations and counts
3b3b4e2 fix(seo): render JSON-LD with plain <script> to avoid next/script client runtime in server components
2384f4b chore(supabase): migrate to Supabase/Onboard helpers; convert server imports to dynamic, add safe serialization, and fix build issues
3ca1457 fix(projects): import safeLogError in projects page
5fcfac9 chore: quick commit of workspace changes
a4170f4 fix(logging): use safeLogError in article routes and home page
a11cca3 fix(tags & articles): pluralize article usage, fetch tags via junctions, avoid implicit PostgREST relations
a130f11 chore(logging): add safeLogError and replace risky console.error calls to avoid Server Component serialization
d14c03a fix(api & pages): pluralize table usage, fetch tags via junction table, grant anon selects via scripts
9daa920 merge: supabase-onboard/migration-safety -> main (apply migration safety)
be8597a chore: commit workspace changes (supabase-onboard/migration-safety)
3851515 Merge PR #19: Supabase onboard/migration safety
efb336b chore(migrations): make DB migrations idempotent; add safe SQL runner and dumps; CI: SKIP_SENTRY in CI
843d802 chore: migrate to Supabase + Onboard ‚Äî server/client separation; add safety scripts and docs (local snapshot)
97b7b17 chore: snapshot commit ‚Äî commit all local changes
cb184f0 chore(supabase/onboard): migrate server helpers to dynamic imports, safe RSS/postcards fallback, and build fixes
148b5d1 fix(supabase): export helper + restore letters route; chore(deps): add pino-pretty devDependency
4a2c3cd chore: centralize supabase clients, safe scripts, add playwright scaffold and deployment CI
78e26a5 –£–¥–∞–ª–µ–Ω–∏–µ –≤—Å–µ—Ö –ª–µ–≥–∞—Å–∏ —Ñ–∞–π–ª–æ–≤ next-auth/prisma –∏ —á–∏—Å—Ç–∫–∞ –ø–æ–¥ Supabase
31c67f1 fix: use only https://www.merkurov.love as SIWE URI for strict server validation
1f31bfc fix: support both https://www.merkurov.love and https://merkurov.love as allowed SIWE URIs
c74909a fix: use fully EIP-4361-compliant SIWE message (6+ lines, all required fields)
d3ea74d fix: correct SIWE message format for Onboard/EIP-4361 compliance
\n-- node scripts/find_bad_metadata.js output --

Scan complete.
\n-- Supabase service_role test --
Skipping Supabase test: NEXT_PUBLIC_SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY not set in env.
\n-- vercel CLI not available or no VERCEL_DEPLOYMENT/VERCEL_PROJECT provided. Skipping Vercel logs. --
\n-- quick grep of generated output for known markers --
./scripts/collect_diagnostics.sh: line 77: rg: command not found
\nDiagnostics collected to: /workspaces/newlove/diagnostics.txt
