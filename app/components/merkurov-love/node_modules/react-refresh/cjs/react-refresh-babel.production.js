/**
 * @license React
 * react-refresh-babel.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

"use strict";
module.exports = function (babel) {
  function createRegistration(programPath, persistentID) {
    var handle = programPath.scope.generateUidIdentifier("c");
    registrationsByProgramPath.has(programPath) ||
      registrationsByProgramPath.set(programPath, []);
    registrationsByProgramPath
      .get(programPath)
      .push({ handle: handle, persistentID: persistentID });
    return handle;
  }
  function isComponentishName(name) {
    return "string" === typeof name && "A" <= name[0] && "Z" >= name[0];
  }
  function findInnerComponents(inferredName, path, callback) {
    var node = path.node;
    switch (node.type) {
      case "Identifier":
        if (!isComponentishName(node.name)) break;
        callback(inferredName, node, null);
        return !0;
      case "FunctionDeclaration":
        return callback(inferredName, node.id, null), !0;
      case "ArrowFunctionExpression":
        if ("ArrowFunctionExpression" === node.body.type) break;
        callback(inferredName, node, path);
        return !0;
      case "FunctionExpression":
        return callback(inferredName, node, path), !0;
      case "CallExpression":
        var argsPath = path.get("arguments");
        if (void 0 === argsPath || 0 === argsPath.length) break;
        var calleePath = path.get("callee");
        switch (calleePath.node.type) {
          case "MemberExpression":
          case "Identifier":
            calleePath = calleePath.getSource();
            if (
              !findInnerComponents(
                inferredName + "$" + calleePath,
                argsPath[0],
                callback
              )
            )
              return !1;
            callback(inferredName, node, path);
            return !0;
          default:
            return !1;
        }
      case "VariableDeclarator":
        if (
          ((argsPath = node.init),
          null !== argsPath &&
            ((calleePath = node.id.name), isComponentishName(calleePath)))
        ) {
          switch (argsPath.type) {
            case "ArrowFunctionExpression":
            case "FunctionExpression":
              break;
            case "CallExpression":
              node = argsPath.callee;
              var calleeType = node.type;
              if (
                "Import" === calleeType ||
                ("Identifier" === calleeType &&
                  (0 === node.name.indexOf("require") ||
                    0 === node.name.indexOf("import")))
              )
                return !1;
              break;
            case "TaggedTemplateExpression":
              break;
            default:
              return !1;
          }
          node = path.get("init");
          if (findInnerComponents(inferredName, node, callback)) return !0;
          calleePath = path.scope.getBinding(calleePath);
          if (void 0 === calleePath) return;
          path = !1;
          calleePath = calleePath.referencePaths;
          for (calleeType = 0; calleeType < calleePath.length; calleeType++) {
            var ref = calleePath[calleeType];
            if (
              !ref.node ||
              "JSXIdentifier" === ref.node.type ||
              "Identifier" === ref.node.type
            ) {
              ref = ref.parent;
              if ("JSXOpeningElement" === ref.type) path = !0;
              else if ("CallExpression" === ref.type) {
                ref = ref.callee;
                var fnName = void 0;
                switch (ref.type) {
                  case "Identifier":
                    fnName = ref.name;
                    break;
                  case "MemberExpression":
                    fnName = ref.property.name;
                }
                switch (fnName) {
                  case "createElement":
                  case "jsx":
                  case "jsxDEV":
                  case "jsxs":
                    path = !0;
                }
              }
              if (path) return callback(inferredName, argsPath, node), !0;
            }
          }
        }
    }
    return !1;
  }
  function getHookCallsSignature(functionNode) {
    functionNode = hookCalls.get(functionNode);
    return void 0 === functionNode
      ? null
      : {
          key: functionNode
            .map(function (call) {
              return call.name + "{" + call.key + "}";
            })
            .join("\n"),
          customHooks: functionNode
            .filter(function (call) {
              a: switch (call.name) {
                case "useState":
                case "React.useState":
                case "useReducer":
                case "React.useReducer":
                case "useEffect":
                case "React.useEffect":
                case "useLayoutEffect":
                case "React.useLayoutEffect":
                case "useMemo":
                case "React.useMemo":
                case "useCallback":
                case "React.useCallback":
                case "useRef":
                case "React.useRef":
                case "useContext":
                case "React.useContext":
                case "useImperativeHandle":
                case "React.useImperativeHandle":
                case "useDebugValue":
                case "React.useDebugValue":
                case "useId":
                case "React.useId":
                case "useDeferredValue":
                case "React.useDeferredValue":
                case "useTransition":
                case "React.useTransition":
                case "useInsertionEffect":
                case "React.useInsertionEffect":
                case "useSyncExternalStore":
                case "React.useSyncExternalStore":
                case "useFormStatus":
                case "React.useFormStatus":
                case "useFormState":
                case "React.useFormState":
                case "useActionStat