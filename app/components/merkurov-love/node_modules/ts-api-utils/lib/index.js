import ts9 from 'typescript';

// src/comments.ts
function forEachToken(node, callback, sourceFile = node.getSourceFile()) {
  const queue = [];
  while (true) {
    if (ts9.isTokenKind(node.kind)) {
      callback(node);
    } else {
      const children = node.getChildren(sourceFile);
      if (children.length === 1) {
        node = children[0];
        continue;
      }
      for (let i = children.length - 1; i >= 0; --i) {
        queue.push(children[i]);
      }
    }
    if (queue.length === 0) {
      break;
    }
    node = queue.pop();
  }
}

// src/comments.ts
function forEachComment(node, callback, sourceFile = node.getSourceFile()) {
  const fullText = sourceFile.text;
  const notJsx = sourceFile.languageVariant !== ts9.LanguageVariant.JSX;
  return forEachToken(
    node,
    (token) => {
      if (token.pos === token.end) {
        return;
      }
      if (token.kind !== ts9.SyntaxKind.JsxText) {
        ts9.forEachLeadingCommentRange(
          fullText,
          // skip shebang at position 0
          token.pos === 0 ? (ts9.getShebang(fullText) ?? "").length : token.pos,
          commentCallback
        );
      }
      if (notJsx || canHaveTrailingTrivia(token)) {
        return ts9.forEachTrailingCommentRange(
          fullText,
          token.end,
          commentCallback
        );
      }
    },
    sourceFile
  );
  function commentCallback(pos, end, kind) {
    callback(fullText, { end, kind, pos });
  }
}
function canHaveTrailingTrivia(token) {
  switch (token.kind) {
    case ts9.SyntaxKind.CloseBraceToken:
      return token.parent.kind !== ts9.SyntaxKind.JsxExpression || !isJsxElementOrFragment(token.parent.parent);
    case ts9.SyntaxKind.GreaterThanToken:
      switch (token.parent.kind) {
        case ts9.SyntaxKind.JsxClosingElement:
        case ts9.SyntaxKind.JsxClosingFragment:
          return !isJsxElementOrFragment(token.parent.parent.parent);
        case ts9.SyntaxKind.JsxOpeningElement:
          return token.end !== token.parent.end;
        case ts9.SyntaxKind.JsxOpeningFragment:
          return false;
        // would be inside the fragment
        case ts9.SyntaxKind.JsxSelfClosingElement:
          return token.end !== token.parent.end || // if end is not equal, this is part of the type arguments list
          !isJsxElementOrFragment(token.parent.parent);
      }
  }
  return true;
}
function isJsxElementOrFragment(node) {
  return node.kind === ts9.SyntaxKind.JsxElement || node.kind === ts9.SyntaxKind.JsxFragment;
}
function isCompilerOptionEnabled(options, option) {
  switch (option) {
    case "allowJs":
      return options.allowJs === undefined ? isCompilerOptionEnabled(options, "checkJs") : options.allowJs;
    case "allowSyntheticDefaultImports":
      return options.allowSyntheticDefaultImports !== undefined ? options.allowSyntheticDefaultImports : isCompilerOptionEnabled(options, "esModuleInterop") || options.module === ts9.ModuleKind.System;
    case "alwaysStrict":
    case "noImplicitAny":
    case "noImplicitThis":
    case "strictBindCallApply":
    case "strictFunctionTypes":
    case "strictNullChecks":
    case "strictPropertyInitialization":
      return isStrictCompilerOptionEnabled(
        options,
        option
      );
    case "declaration":
      return options.declaration || isCompilerOptionEnabled(options, "composite");
    case "declarationMap":
    case "emitDeclarationOnly":
    case "stripInternal":
      return options[option] === true && isCompilerOptionEnabled(options, "declaration");
    case "incremental":
      return options.incremental === undefined ? isCompilerOptionEnabled(options, "composite") : options.incremental;
    case "noUncheckedIndexedAccess":
      return options.noUncheckedIndexedAccess === true && isCompilerOptionEnabled(options, "strictNullChecks");
    case "skipDefaultLibCheck":
      return options.skipDefaultLibCheck || isCompilerOptionEnabled(options, "skipLibCheck");
    case "suppressImplicitAnyIndexErrors":
      return (
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        options.suppressImplicitAnyIndexErrors === true && isCompilerOptionEnabled(options, "noImplicitAny")
      );
  }
  return options[option] === true;
}
function isStrictCompilerOptionEnabled(options, option) {
  return (options.strict ? options[option] !== false : options[option] === true) && (option !== "strictPropertyInitialization" || isStrictCompilerOptionEnabled(options, "strictNullChecks"));
}
function isModifierFlagSet(node, flag) {
  return isFlagSet(ts9.getCombinedModifierFlags(node), flag);
}
function isFlagSet(allFlags, flag) {
  return (allFlags & flag) !== 0;
}
function isFlagSetOnObject(obj, flag) {
  return isFlagSet(obj.flags, flag);
}
var isNodeFlagSet = isFlagSetOnObject;
function isObjectFlagSet(objectType, flag) {
  return isFlagSet(objectType.objectFlags, flag);
}
var isSymbolFlagSet = isFlagSetOnObject;
function isTransientSymbolLinksFlagSet(links, flag) {
  return isFlagSet(links.checkFlags, flag);
}
var isTypeFlagSet = isFlagSetOnObject;

// src/modifiers.ts
function includesModifier(modifiers, ...kinds) {
  if (modifiers === undefined) {
    return false;
  }
  for (const modifier of modifiers) {
    if (kinds.includes(modifier.kind)) {
      return true;
    }
  }
  return false;
}
function isAssignmentKind(kind) {
  return kind >= ts9.SyntaxKind.FirstAssignment && kind <= ts9.SyntaxKind.LastAssignment;
}
function isNumericPropertyName(name) {
  return String(+name) === name;
}
function isValidPropertyAccess(text, languageVersion = ts9.ScriptTarget.Latest) {
  if (text.length === 0) {
    return false;
  }
  let ch = text.codePointAt(0);
  if (!ts9.isIdentifierStart(ch, languageVersion)) {
    return false;
  }
  for (let i = charSize(ch); i < text.length; i += charSize(ch)) {
    ch = text.codePointAt(i);
    if (!ts9.isIdentifierPart(ch, languageVersion)) {
      return false;
    }
  }
  return true;
}
function charSize(ch) {
  return ch >= 65536 ? 2 : 1;
}

// src/nodes/access.ts
var AccessKind = /* @__PURE__ */ ((AccessKind2) => {
  AccessKind2[AccessKind2["None"] = 0] = "None";
  AccessKind2[AccessKind2["Read"] = 1] = "Read";
  AccessKind2[AccessKind2["Write"] = 2] = "Write";
  AccessKind2[AccessKind2["Delete"] = 4] = "Delete";
  AccessKind2[AccessKind2["ReadWrite"] = 3] = "ReadWrite";
  return AccessKind2;
})(AccessKind || {});
function getAccessKind(node) {
  const parent = node.parent;
  switch (parent.kind) {
    case ts9.SyntaxKind.ArrayLiteralExpression:
    case ts9.SyntaxKind.SpreadAssignment:
    case ts9.SyntaxKind.SpreadElement:
      return isInDestructuringAssignment(
        parent
      ) ? 2 /* Write */ : 1 /* Read */;
    case ts9.SyntaxKind.ArrowFunction:
      return parent.body === node ? 1 /* Read */ : 2 /* Write */;
    case ts9.SyntaxKind.AsExpression:
    case ts9.SyntaxKind.NonNullExpression:
    case ts9.SyntaxKind.ParenthesizedExpression:
    case ts9.SyntaxKind.TypeAssertionExpression:
      return getAccessKind(parent);
    case ts9.SyntaxKind.AwaitExpression:
    case ts9.SyntaxKind.CallExpression:
    case ts9.SyntaxKind.CaseClause:
    case ts9.SyntaxKind.ComputedPropertyName:
    case ts9.SyntaxKind.ConditionalExpression:
    case ts9.SyntaxKind.Decorator:
    case ts9.SyntaxKind.DoStatement:
    case ts9.SyntaxKind.ElementAccessExpression:
    case ts9.SyntaxKind.ExpressionStatement:
    case ts9.SyntaxKind.ForStatement:
    case ts9.SyntaxKind.IfStatement:
    case ts9.SyntaxKind.JsxElement:
    case ts9.SyntaxKind.JsxExpression:
    case ts9.SyntaxKind.JsxOpeningElement:
    case ts9.SyntaxKind.JsxSelfClosingElement:
    case ts9.SyntaxKind.JsxSpreadAttribute:
    case ts9.SyntaxKind.NewExpression:
    case ts9.SyntaxKind.ReturnStatement:
    case ts9.SyntaxKind.SwitchStatement:
    case ts9.SyntaxKind.TaggedTemplateExpression:
    case ts9.SyntaxKind.TemplateSpan:
    case ts9.SyntaxKind.ThrowStatement:
    case ts9.SyntaxKind.TypeOfExpression:
    case ts9.SyntaxKind.VoidExpression:
    case ts9.SyntaxKind.WhileStatement:
    case ts9.SyntaxKind.WithStatement:
    case ts9.SyntaxKind.YieldExpression:
      return 1 /* Read */;
    case ts9.SyntaxKind.BinaryExpression:
      return parent.right === node ? 1 /* Read */ : !isAssignmentKind(parent.operatorToken.kind) ? 1 /* Read */ : parent.operatorToken.kind === ts9.SyntaxKind.EqualsToken ? 2 /* Write */ : 3 /* ReadWrite */;
    case ts9.SyntaxKind.BindingElement:
    case ts9.SyntaxKind.EnumMember:
    case ts9.SyntaxKind.JsxAttribute:
    case ts9.SyntaxKind.Parameter:
    case ts9.SyntaxKind.PropertyDeclaration:
    case ts9.SyntaxKind.VariableDeclaration:
      return parent.initializer === node ? 1 /* Read */ : 0 /* None */;
    case ts9.SyntaxKind.DeleteExpression:
      return 4 /* Delete */;
    case ts9.SyntaxKind.ExportAssignment:
      return parent.isExportEquals ? 1 /* Read */ : 0 /* None */;
    case ts9.SyntaxKind.ExpressionWithTypeArguments:
      return parent.parent.token === ts9.SyntaxKind.ExtendsKeyword && parent.parent.parent.kind !== ts9.SyntaxKind.InterfaceDeclaration ? 1 /* Read */ : 0 /* None */;
    case ts9.SyntaxKind.ForInStatement:
    case ts9.SyntaxKind.ForOfStatement:
      return parent.initializer === node ? 2 /* Write */ : 1 /* Read */;
    case ts9.SyntaxKind.PostfixUnaryExpression:
      return 3 /* ReadWrite */;
    case ts9.SyntaxKind.PrefixUnaryExpression:
      return parent.operator === ts9.SyntaxKind.PlusPlusToken || parent.operator === ts9.SyntaxKind.MinusMinusToken ? 3 /* ReadWrite */ : 1 /* Read */;
    case ts9.SyntaxKind.PropertyAccessExpression:
      return parent.expression === node ? 1 /* Read */ : 0 /* None */;
    case ts9.SyntaxKind.PropertyAssignment:
      return parent.name === node ? 0 /* None */ : isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;
    case ts9.SyntaxKind.ShorthandPropertyAssignment:
      return parent.objectAssignmentInitializer === node ? 1 /* Read */ : isInDestructuringAssignment(parent) ? 2 /* Write */ : 1 /* Read */;
  }
  return 0 /* None */;
}
function isInDestructuringAssignment(node) {
  switch (node.kind) {
    case ts9.SyntaxKind.ShorthandPropertyAssignment:
      if (node.objectAssignmentInitializer !== undefined) {
        return true;
      }
    // falls through
    case ts9.SyntaxKind.PropertyAssignment:
    case ts9.SyntaxKind.SpreadAssignment:
      node = node.parent;
      break;
    case ts9.SyntaxKind.SpreadElement:
      if (node.parent.kind !== ts9.SyntaxKind.ArrayLiteralExpression) {
        return false;
      }
      node = node.parent;
  }
  while (true) {
    switch (node.parent.kind) {
      case ts9.SyntaxKind.ArrayLiteralExpression:
      case ts9.SyntaxKind.ObjectLiteralExpression:
        node = node.parent;
        break;
      case ts9.SyntaxKind.BinaryExpression:
        return node.parent.left === node && node.parent.operatorToken.kind === ts9.SyntaxKind.EqualsToken;
      case ts9.SyntaxKind.ForOfStatement:
        return node.parent.initializer === node;
      case ts9.SyntaxKind.PropertyAssignment:
      case ts9.SyntaxKind.SpreadAssignment:
        node = node.parent.parent;
        break;
      case ts9.SyntaxKind.SpreadElement:
        if (node.parent.parent.kind !== ts9.SyntaxKind.ArrayLiteralExpression) {
          return false;
        }
        node = node.parent.parent;
        break;
      default:
        return false;
    }
  }
}
function isAbstractKeyword(node) {
  return node.kind === ts9.SyntaxKind.AbstractKeyword;
}
function isAccessorKeyword(node) {
  return node.kind === ts9.SyntaxKind.AccessorKeyword;
}
function isAnyKeyword(node) {
  return node.kind === ts9.SyntaxKind.AnyKeyword;
}
function isAssertKeyword(node) {
  return node.kind === ts9.SyntaxKind.AssertKeyword;
}
function isAssertsKeyword(node) {
  return node.kind === ts9.SyntaxKind.AssertsKeyword;
}
function isAsyncKeyword(node) {
  return node.kind === ts9.SyntaxKind.AsyncKeyword;
}
function isAwaitKeyword(node) {
  return node.kind === ts9.SyntaxKind.AwaitKeyword;
}
function isBigIntKeyword(node) {
  return node.kind === ts9.SyntaxKind.BigIntKeyword;
}
function isBooleanKeyword(node) {
  return node.kind === ts9.SyntaxKind.BooleanKeyword;
}
function isColonToken(node) {
  return node.kind === ts9.SyntaxKind.ColonToken;
}
function isConstKeyword(node) {
  return node.kind === ts9.SyntaxKind.ConstKeyword;
}
function isDeclareKeyword(node) {
  return node.kind === ts9.SyntaxKind.DeclareKeyword;
}
function isDefaultKeyword(node) {
  return node.kind === ts9.SyntaxKind.DefaultKeyword;
}
function isDotToken(node) {
  return node.kind === ts9.SyntaxKind.DotToken;
}
function isEndOfFileToken(node) {
  return node.kind === ts9.SyntaxKind.EndOfFileToken;
}
function isEqualsGreaterThanToken(node) {
  return node.kind === ts9.SyntaxKind.EqualsGreaterThanToken;
}
function isEqualsToken(node) {
  return node.kind === ts9.SyntaxKind.EqualsToken;
}
function isExclamationToken(node) {
  return node.kind === ts9.SyntaxKind.ExclamationToken;
}
function isExportKeyword(node) {
  return node.kind === ts9.SyntaxKind.ExportKeyword;
}
function isFalseKeyword(node) {
  return node.kind === ts9.SyntaxKind.FalseKeyword;
}
function isFalseLiteral(node) {
  return node.kind === ts9.SyntaxKind.FalseKeyword;
}
function isImportExpression(node) {
  return node.kind === ts9.SyntaxKind.ImportKeyword;
}
function isImportKeyword(node) {
  return node.kind === ts9.SyntaxKind.ImportKeyword;
}
function isInKeyword(node) {
  return node.kind === ts9.SyntaxKind.InKeyword;
}
function isJSDocText(node) {
  return node.kind === ts9.SyntaxKind.JSDocText;
}
function isJsonMinusNumericLiteral(node) {
  return node.kind === ts9.SyntaxKind.PrefixUnaryExpression;
}
function isNeverKeyword(node) {
  return node.kind === ts9.SyntaxKind.NeverKeyword;
}
function isNullKeyword(node) {
  return node.kind === ts9.SyntaxKind.NullKeyword;
}
function isNullLiteral(node) {
  return node.kind === ts9.SyntaxKind.NullKeyword;
}
function isNumberKeyword(node) {
  return node.kind === ts9.SyntaxKind.NumberKeyword;
}
function isObjectKeyword(node) {
  return node.kind === ts9.SyntaxKind.ObjectKeyword;
}
function isOutKeyword(node) {
  return node.kind === ts9.SyntaxKind.OutKeyword;
}
function isOverrideKeyword(node) {
  return node.kind === ts9.SyntaxKind.OverrideKeyword;
}
function isPrivateKeyword(node) {
  return node.kind === ts9.SyntaxKind.PrivateKeyword;
}
function isProtectedKeyword(node) {
  return node.kind === ts9.SyntaxKind.ProtectedKeyword;
}
function isPublicKeyword(node) {
  return node.kind === ts9.SyntaxKind.PublicKeyword;
}
function isQuestionDotToken(node) {
  return node.kind === ts9.SyntaxKind.QuestionDotToken;
}
function isQuestionToken(node) {
  return node.kind === ts9.SyntaxKind.QuestionToken;
}
function isReadonlyKeyword(node) {
  return node.kind === ts9.SyntaxKind.ReadonlyKeyword;
}
function isStaticKeyword(node) {
  return node.kind === ts9.SyntaxKind.StaticKeyword;
}
function isStringKeyword(node) {
  return node.kind === ts9.SyntaxKind.StringKeyword;
}
function isSuperExpression(node) {
  return node.kind === ts9.SyntaxKind.SuperKeyword;
}
function isSuperKeyword(node) {
  return node.kind === ts9.SyntaxKind.SuperKeyword;
}
function isSymbolKeyword(node) {
  return node.kind === ts9.SyntaxKind.SymbolKeyword;
}
function isSyntaxList(node) {
  return node.kind === ts9.SyntaxKind.SyntaxList;
}
function isThisExpression(node) {
  return node.kind === ts9.SyntaxKind.ThisKeyword;
}
function isThisKeyword(node) {
  return node.kind === ts9.SyntaxKind.ThisKeyword;
}
function isTrueKeyword(node) {
  return node.kind === ts9.SyntaxKind.TrueKeyword;
}
function isTrueLiteral(node) {
  return node.kind === ts9.SyntaxKind.TrueKeyword;
}
function isUndefinedKeyword(node) {
  return node.kind === ts9.SyntaxKind.UndefinedKeyword;
}
function isUnknownKeyword(node) {
  return node.kind === ts9.SyntaxKind.UnknownKeyword;
}
function isVoidKeyword(node) {
  return node.kind === ts9.SyntaxKind.VoidKeyword;
}
var [tsMajor, tsMinor] = ts9.versionMajorMinor.split(".").map((raw) => Number.parseInt(raw, 10));
function isTsVersionAtLeast(major, minor = 0) {
  return tsMajor > major || tsMajor === major && tsMinor >= minor;
}

// src/nodes/typeGuards/union.ts
function hasDecorators(node) {
  return ts9.isParameter(node) || ts9.isPropertyDeclaration(node) || ts9.isMethodDeclaration(node) || ts9.isGetAccessorDeclaration(node) || ts9.isSetAccessorDeclaration(node) || ts9.isClassExpression(node) || ts9.isClassDeclaration(node);
}
function hasExpressionInitializer(node) {
  return ts9.isVariableDeclaration(node) || ts9.isParameter(node) || ts9.isBindingElement(node) || ts9.isPropertyDeclaration(node) || ts9.isPropertyAssignment(node) || ts9.isEnumMember(node);
}
function hasInitializer(node) {
  return hasExpressionInitializer(node) || ts9.isForStatement(node) || ts9.isForInStatement(node) || ts9.isForOfStatement(node) || ts9.isJsxAttribute(node);
}
function hasJSDoc(node) {
  if (
    // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5
    isAccessorDeclaration(node) || ts9.isArrowFunction(node) || ts9.isBlock(node) || ts9.isBreakStatement(node) || ts9.isCallSignatureDeclaration(node) || ts9.isCaseClause(node) || // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5
    isClassLikeDeclaration(node) || ts9.isConstructorDeclaration(node) || ts9.isConstructorTypeNode(node) || ts9.isConstructSignatureDeclaration(node) || ts9.isContinueStatement(node) || ts9.isDebuggerStatement(node) || ts9.isDoStatement(node) || ts9.isEmptyStatement(node) || isEndOfFileToken(node) || ts9.isEnumDeclaration(node) || ts9.isEnumMember(node) || ts9.isExportAssignment(node) || ts9.isExportDeclaration(node) || ts9.isExportSpecifier(node) || ts9.isExpressionStatement(node) || ts9.isForInStatement(node) || ts9.isForOfStatement(node) || ts9.isForStatement(node) || ts9.isFunctionDeclaration(node) || ts9.isFunctionExpression(node) || ts9.isFunctionTypeNode(node) || ts9.isIfStatement(node) || ts9.isImportDeclaration(node) || ts9.isImportEqualsDeclaration(node) || ts9.isIndexSignatureDeclaration(node) || ts9.isInterfaceDeclaration(node) || ts9.isJSDocFunctionType(node) || ts9.isLabeledStatement(node) || ts9.isMethodDeclaration(node) || ts9.isMethodSignature(node) || ts9.isModuleDeclaration(node) || ts9.isNamedTupleMember(node) || ts9.isNamespaceExportDeclaration(node) || ts9.isParameter(node) || ts9.isParenthesizedExpression(node) || ts9.isPropertyAssignment(node) || ts9.isPropertyDeclaration(node) || ts9.isPropertySignature(node) || ts9.isReturnStatement(node) || ts9.isShorthandPropertyAssignment(node) || ts9.isSpreadAssignment(node) || ts9.isSwitchStatement(node) || ts9.isThrowStatement(node) || ts9.isTryStatement(node) || ts9.isTypeAliasDeclaration(node) || ts9.isVariableDeclaration(node) || ts9.isVariableStatement(node) || ts9.isWhileStatement(node) || ts9.isWithStatement(node)
  ) {
    return true;
  }
  if (isTsVersionAtLeast(4, 4) && ts9.isClassStaticBlockDeclaration(node)) {
    return true;
  }
  if (isTsVersionAtLeast(5, 0) && (ts9.isBinaryExpression(node) || ts9.isElementAccessExpression(node) || ts9.isIdentifier(node) || ts9.isJSDocSignature(node) || ts9.isObjectLiteralExpression(node) || ts9.isPropertyAccessExpression(node) || ts9.isTypeParameterDeclaration(node))) {
    return true;
  }
  return false;
}
function hasModifiers(node) {
  return ts9.isTypeParameterDeclaration(node) || ts9.isParameter(node) || ts9.isConstructorTypeNode(node) || ts9.isPropertySignature(node) || ts9.isPropertyDeclaration(node) || ts9.isMethodSignature(node) || ts9.isMethodDeclaration(node) || ts9.isConstructorDeclaration(node) || ts9.isGetAccessorDeclaration(node) || ts9.isSetAccessorDeclaration(node) || ts9.isIndexSignatureDeclaration(node) || ts9.isFunctionExpression(node) || ts9.isArrowFunction(node) || ts9.isClassExpression(node) || ts9.isVariableStatement(node) || ts9.isFunctionDeclaration(node) || ts9.isClassDeclaration(node) || ts9.isInterfaceDeclaration(node) || ts9.isTypeAliasDeclaration(node) || ts9.isEnumDeclaration(node) || ts9.isModuleDeclaration(node) || ts9.isImportEqualsDeclaration(node) || ts9.isImportDeclaration(node) || ts9.isExportAssignment(node) || ts9.isExportDeclaration(node);
}
function hasType(node) {
  return isSignatureDeclaration(node) || ts9.isVariableDeclaration(node) || ts9.isParameter(node) || ts9.isPropertySignature(node) || ts9.isPropertyDeclaration(node) || ts9.isTypePredicateNode(node) || ts9.isParenthesizedTypeNode(node) || ts9.isTypeOperatorNode(node) || ts9.isMappedTypeNode(node) || ts9.isAssertionExpression(node) || ts9.isTypeAliasDeclaration(node) || ts9.isJSDocTypeExpression(node) || ts9.isJSDocNonNullableType(node) || ts9.isJSDocNullableType(node) || ts9.isJSDocOptionalType(node) || ts9.isJSDocVariadicType(node);
}
function hasTypeArguments(node) {
  return ts9.isCallExpression(node) || ts9.isNewExpression(node) || ts9.isTaggedTemplateExpression(node) || ts9.isJsxOpeningElement(node) || ts9.isJsxSelfClosingElement(node);
}
function isAccessExpression(node) {
  return ts9.isPropertyAccessExpression(node) || ts9.isElementAccessExpression(node);
}
function isAccessibilityModifier(node) {
  return isPublicKeyword(node) || isPrivateKeyword(node) || isProtectedKeyword(node);
}
function isAccessorDeclaration(node) {
  return ts9.isGetAccessorDeclaration(node) || ts9.isSetAccessorDeclaration(node);
}
function isArrayBindingElement(node) {
  return ts9.isBindingElement(node) || ts9.isOmittedExpression(node);
}
function isArrayBindingOrAssignmentPattern(node) {
  return ts9.isArrayBindingPattern(node) || ts9.isArrayLiteralExpression(node);
}
function isAssignmentPattern(node) {
  return ts9.isObjectLiteralExpression(node) || ts9.isArrayLiteralExpression(node);
}
function isBindingOrAssignmentElementRestIndicator(node) {
  if (ts9.isSpreadElement(node) || ts9.isSpreadAssignment(node)) {
    return true;
  }
  if (isTsVersionAtLeast(4, 4)) {
    return ts9.isDotDotDotToken(node);
  }
  return false;
}
function isBindingOrAssignmentElementTarget(node) {
  return isBindingOrAssignmentPattern(node) || ts9.isIdentifier(node) || ts9.isPropertyAccessExpression(node) || ts9.isElementAccessExpression(node) || ts9.isOmittedExpression(node);
}
function isBindingOrAssignmentPattern(node) {
  return isObjectBindingOrAssignmentPattern(node) || isArrayBindingOrAssignmentPattern(node);
}
function isBindingPattern(node) {
  return ts9.isObjectBindingPattern(node) || ts9.isArrayBindingPattern(node);
}
function isBlockLike(node) {
  return ts9.isSourceFile(node) || ts9.isBlock(node) || ts9.isModuleBlock(node) || ts9.isCaseOrDefaultClause(node);
}
function isBooleanLiteral(node) {
  return isTrueLiteral(node) || isFalseLiteral(node);
}
function isClassLikeDeclaration(node) {
  return ts9.isClassDeclaration(node) || ts9.isClassExpression(node);
}
function isClassMemberModifier(node) {
  return isAccessibilityModifier(node) || isReadonlyKeyword(node) || isStaticKeyword(node) || isAccessorKeyword(node);
}
function isDeclarationName(node) {
  return ts9.isIdentifier(node) || ts9.isPrivateIdentifier(node) || ts9.isStringLiteralLike(node) || ts9.isNumericLiteral(node) || ts9.isComputedPropertyName(node) || ts9.isElementAccessExpression(node) || isBindingPattern(node) || isEntityNameExpression(node);
}
function isDeclarationWithTypeParameterChildren(node) {
  return isSignatureDeclaration(node) || // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5
  isClassLikeDeclaration(node) || ts9.isInterfaceDeclaration(node) || ts9.isTypeAliasDeclaration(node) || ts9.isJSDocTemplateTag(node);
}
function isDeclarationWithTypeParameters(node) {
  return isDeclarationWithTypeParameterChildren(node) || ts9.isJSDocTypedefTag(node) || ts9.isJSDocCallbackTag(node) || ts9.isJSDocSignature(node);
}
function isDestructuringPattern(node) {
  return isBindingPattern(node) || ts9.isObjectLiteralExpression(node) || ts9.isArrayLiteralExpression(node);
}
function isEntityNameExpression(node) {
  return ts9.isIdentifier(node) || isPropertyAccessEntityNameExpression(node);
}
function isEntityNameOrEntityNameExpression(node) {
  return ts9.isEntityName(node) || isEntityNameExpression(node);
}
function isForInOrOfStatement(node) {
  return ts9.isForInStatement(node) || ts9.isForOfStatement(node);
}
function isFunctionLikeDeclaration(node) {
  return ts9.isFunctionDeclaration(node) || ts9.isMethodDeclaration(node) || ts9.isGetAccessorDeclaration(node) || ts9.isSetAccessorDeclaration(node) || ts9.isConstructorDeclaration(node) || ts9.isFunctionExpression(node) || ts9.isArrowFunction(node);
}
function isJSDocComment(node) {
  if (isJSDocText(node)) {
    return true;
  }
  if (isTsVersionAtLeast(4, 4)) {
    return ts9.isJSDocLink(node) || ts9.isJSDocLinkCode(node) || ts9.isJSDocLinkPlain(node);
  }
  return false;
}
function isJSDocNamespaceBody(node) {
  return ts9.isIdentifier(node) || isJSDocNamespaceDeclaration(node);
}
function isJSDocTypeReferencingNode(node) {
  return ts9.isJSDocVariadicType(node) || ts9.isJSDocOptionalType(node) || ts9.isJSDocNullableType(node) || ts9.isJSDocNonNullableType(node);
}
function isJsonObjectExpression(node) {
  return ts9.isObjectLiteralExpression(node) || ts9.isArrayLiteralExpression(node) || isJsonMinusNumericLiteral(node) || ts9.isNumericLiteral(node) || ts9.isStringLiteral(node) || isBooleanLiteral(node) || isNullLiteral(node);
}
function isJsxAttributeLike(node) {
  return ts9.isJsxAttribute(node) || ts9.isJsxSpreadAttribute(node);
}
function isJsxAttributeValue(node) {
  return ts9.isStringLiteral(node) || ts9.isJsxExpression(node) || ts9.isJsxElement(node) || ts9.isJsxSelfClosingElement(node) || ts9.isJsxFragment(node);
}
function isJsxChild(node) {
  return ts9.isJsxText(node) || ts9.isJsxExpression(node) || ts9.isJsxElement(node) || ts9.isJsxSelfClosingElement(node) || ts9.isJsxFragment(node);
}
function isJsxTagNameExpression(node) {
  return ts9.isIdentifier(node) || isThisExpression(node) || isJsxTagNamePropertyAccess(node);
}
function isLiteralToken(node) {
  return ts9.isNumericLiteral(node) || ts9.isBigIntLiteral(node) || ts9.isStringLiteral(node) || ts9.isJsxText(node) || ts9.isRegularExpressionLiteral(node) || ts9.isNoSubstitutionTemplateLiteral(node);
}
function isModuleBody(node) {
  return isNamespaceBody(node) || isJSDocNamespaceBody(node);
}
function isModuleName(node) {
  return ts9.isIdentifier(node) || ts9.isStringLiteral(node);
}
function isModuleReference(node) {
  return ts9.isEntityName(node) || ts9.isExternalModuleReference(node);
}
function isNamedImportBindings(node) {
  return ts9.isNamespaceImport(node) || ts9.isNamedImports(node);
}
function isNamedImportsOrExports(node) {
  return ts9.isNamedImports(node) || ts9.isNamedExports(node);
}
function isNamespaceBody(node) {
  return ts9.isModuleBlock(node) || isNamespaceDeclaration(node);
}
function isObjectBindingOrAssignmentElement(node) {
  return ts9.isBindingElement(node) || ts9.isPropertyAssignment(node) || ts9.isShorthandPropertyAssignment(node) || ts9.isSpreadAssignment(node);
}
function isObjectBindingOrAssignmentPattern(node) {
  return ts9.isObjectBindingPattern(node) || ts9.isObjectLiteralExpression(node);
}
function isObjectTypeDeclaration(node) {
  return (
    // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5
    isClassLikeDeclaration(node) || ts9.isInterfaceDeclaration(node) || ts9.isTypeLiteralNode(node)
  );
}
function isParameterPropertyModifier(node) {
  return isAccessibilityModifier(node) || isReadonlyKeyword(node);
}
function isPropertyNameLiteral(node) {
  return ts9.isIdentifier(node) || ts9.isStringLiteralLike(node) || ts9.isNumericLiteral(node);
}
function isPseudoLiteralToken(node) {
  return ts9.isTemplateHead(node) || ts9.isTemplateMiddle(node) || ts9.isTemplateTail(node);
}
function isSignatureDeclaration(node) {
  return ts9.isCallSignatureDeclaration(node) || ts9.isConstructSignatureDeclaration(node) || ts9.isMethodSignature(node) || ts9.isIndexSignatureDeclaration(node) || ts9.isFunctionTypeNode(node) || ts9.isConstructorTypeNode(node) || ts9.isJSDocFunctionType(node) || ts9.isFunctionDeclaration(node) || ts9.isMethodDeclaration(node) || ts9.isConstructorDeclaration(node) || // eslint-disable-next-line @typescript-eslint/no-deprecated -- Keep compatibility with ts <5
  isAccessorDeclaration(node) || ts9.isFunctionExpression(node) || ts9.isArrowFunction(node);
}
function isSuperProperty(node) {
  return isSuperPropertyAccessExpression(node) || isSuperElementAccessExpression(node);
}
function isTypeOnlyCompatibleAliasDeclaration(node) {
  if (ts9.isImportClause(node) || ts9.isImportEqualsDeclaration(node) || ts9.isNamespaceImport(node) || ts9.isImportOrExportSpecifier(node)) {
    return true;
  }
  if (isTsVersionAtLeast(5, 0) && (ts9.isExportDeclaration(node) || ts9.isNamespaceExport(node))) {
    return true;
  }
  return false;
}
function isTypeReferenceType(node) {
  return ts9.isTypeReferenceNode(node) || ts9.isExpressionWithTypeArguments(node);
}
function isUnionOrIntersectionTypeNode(node) {
  return ts9.isUnionTypeNode(node) || ts9.isIntersectionTypeNode(node);
}
function isVariableLikeDeclaration(node) {
  return ts9.isVariableDeclaration(node) || ts9.isParameter(node) || ts9.isBindingElement(node) || ts9.isPropertyDeclaration(node) || ts9.isPropertyAssignment(node) || ts9.isPropertySignature(node) || ts9.isJsxAttribute(node) || ts9.isShorthandPropertyAssignment(node) || ts9.isEnumMember(node) || ts9.isJSDocPropertyTag(node) || ts9.isJSDocParameterTag(node);
}

// src/nodes/typeGuards/compound.ts
function isConstAssertionExpression(node) {
  return ts9.isTypeReferenceNode(node.type) && ts9.isIdentifier(node.type.typeName) && node.type.typeName.escapedText === "const";
}
function isIterationStatement(node) {
  switch (node.kind) {
    case ts9.SyntaxKind.DoStatement:
    case ts9.SyntaxKind.ForInStatement:
    case ts9.SyntaxKind.ForOfStatement:
    case ts9.SyntaxKind.ForStatement:
    case ts9.SyntaxKind.WhileStatement:
      return true;
    default:
      return false;
  }
}
function isJSDocNamesp