*** Begin Patch
*** Update File: lib/attachTagsToArticles.js
@@
-// lib/attachTagsToArticles.js
-// Temporary safe helper: skip DB access to junction/table and return articles
-// with an empty `tags` array. This avoids permission errors while we fix DB.
-export async function attachTagsToArticles(_supabase, articles) {
-  if (!Array.isArray(articles)) return articles;
-  if (articles.length === 0) return articles;
-
-  // Return a fully-serializable copy with empty tags to satisfy Server Components
-  return JSON.parse(JSON.stringify(articles.map(a => ({ ...a, tags: [] }))));
-}
+// lib/attachTagsToArticles.js
+// Minimal safe stub used for emergency production stabilization.
+// It returns a guaranteed-serializable array of articles with empty `tags`.
+export async function attachTagsToArticles(supabase, articles) {
+  if (!Array.isArray(articles)) return [];
+
+  // Возвращаем чистый, глубоко клонированный массив с гарантированно пустыми тегами
+  // Этот массив не должен содержать несериализуемых объектов.
+  return JSON.parse(JSON.stringify(articles.map(a => ({ ...a, tags: [] }))));
+}
*** End Patch

*** Begin Patch
*** Update File: lib/metadataSanitize.ts
@@
   function isStreamLike(v: any) {
     const name = constructorName(v);
     return name === 'ReadableStream' || name === 'Stream' || (v && typeof v.getReader === 'function');
   }
+
+  function isMapLike(v: any) {
+    return v instanceof Map || Object.prototype.toString.call(v) === '[object Map]';
+  }
+
+  function isSetLike(v: any) {
+    return v instanceof Set || Object.prototype.toString.call(v) === '[object Set]';
+  }
+
+  function isArrayBufferLike(v: any) {
+    return v instanceof ArrayBuffer || ArrayBuffer.isView(v) || Object.prototype.toString.call(v).includes('ArrayBuffer') || Object.prototype.toString.call(v).includes('Uint8');
+  }
+
+  function isURLSearchParams(v: any) {
+    return Object.prototype.toString.call(v) === '[object URLSearchParams]';
+  }
@@
     // Arrays: sanitize items and drop undefined
     if (Array.isArray(value)) {
       const arr = value.map((it, i) => sanitize(it, path.concat(String(i)))).filter(v => v !== undefined);
       return arr;
     }
+
+    // Map -> convert to plain object with sanitized keys
+    if (isMapLike(value)) {
+      logDiag(path, value, 'map-like');
+      const out: any = {};
+      try {
+        for (const [k, v] of value.entries()) {
+          const key = typeof k === 'string' ? k : String(k);
+          const sv = sanitize(v, path.concat(String(key)));
+          if (sv !== undefined) out[key] = sv;
+        }
+        return out;
+      } catch (e) {
+        logDiag(path, value, 'map-convert-failed');
+        return undefined;
+      }
+    }
+
+    // Set -> convert to array
+    if (isSetLike(value)) {
+      logDiag(path, value, 'set-like');
+      try {
+        const arr = Array.from(value).map((it, i) => sanitize(it, path.concat(String(i)))).filter(v => v !== undefined);
+        return arr;
+      } catch (e) {
+        logDiag(path, value, 'set-convert-failed');
+        return undefined;
+      }
+    }
+
+    // ArrayBuffer / TypedArray -> convert to array of numbers
+    if (isArrayBufferLike(value)) {
+      logDiag(path, value, 'arraybuffer-like');
+      try {
+        const view = ArrayBuffer.isView(value) ? value : new Uint8Array(value);
+        return Array.from(view as any).slice(0, 10240); // cap length
+      } catch (e) {
+        logDiag(path, value, 'arraybuffer-convert-failed');
+        return undefined;
+      }
+    }
+
+    if (isURLSearchParams(value)) {
+      try {
+        return value.toString();
+      } catch (e) {
+        logDiag(path, value, 'urlsearchparams');
+        return undefined;
+      }
+    }
@@
-      const out: any = {};
+      // If this is a class instance with custom toJSON, prefer that
+      if (typeof value.toJSON === 'function' && value.constructor && value.constructor.name !== 'Object') {
+        try {
+          const j = value.toJSON();
+          return sanitize(j, path.concat('<toJSON>'));
+        } catch (e) {
+          logDiag(path, value, 'toJSON-failed');
+        }
+      }
+
+      const out: any = {};
*** End Patch
